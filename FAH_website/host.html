<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>H√¥te Quiz - FAH Marie-Curie</title>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Host+Grotesk:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <style>
    /* (garde ton CSS inchang√© ‚Äî j'ai conserv√© le m√™me CSS que l'original pour la bri√®vet√©) */
    * { margin:0; padding:0; box-sizing:border-box }
    body{font-family:"Host Grotesk",sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
    .container{width:100%;max-width:1200px}
    .card{background:white;border-radius:20px;padding:40px;box-shadow:0 20px 60px rgba(0,0,0,0.3)}
    /* ... reste du CSS identique ... */
    .waiting-screen{text-align:center}
    .quiz-title{font-size:2rem;font-weight:600;color:#0d0d0d;margin-bottom:20px}
    .code-display{background:linear-gradient(135deg,#FBE01D 0%,#fff4a4 100%);padding:40px;border-radius:15px;margin:30px 0}
    .code-label{font-size:1.2rem;color:#666;margin-bottom:10px}
    .code-value{font-size:4rem;font-weight:700;color:#0d0d0d;letter-spacing:10px}
    #qrcode{margin:20px auto}
    #qrcode canvas{border-radius:10px}
    .participants-list{margin:30px 0;text-align:left}
    .participants-title{font-size:1.3rem;font-weight:600;margin-bottom:15px;color:#0d0d0d}
    .participant-item{padding:12px 20px;background:#f8f9fa;border-radius:8px;margin-bottom:8px;display:flex;justify-content:space-between;align-items:center}
    .participant-name{font-weight:500}
    .participant-score{color:#667eea;font-weight:600}
    .btn{padding:15px 40px;border:none;border-radius:50px;font-family:inherit;font-size:1rem;font-weight:600;cursor:pointer;transition:all .3s}
    .btn-primary{background:#0d0d0d;color:white}
    .btn-primary:hover{background:#2d2d2d;transform:translateY(-2px)}
    .btn-primary:disabled{opacity:.5;cursor:not-allowed}
    .question-screen{display:none}
    .question-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:30px}
    .question-number{font-size:1.2rem;color:#666}
    .timer{font-size:2rem;font-weight:700;color:#667eea}
    .timer.warning{color:#e74c3c;animation:pulse 1s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
    .question-text{font-size:1.8rem;font-weight:600;color:#0d0d0d;margin-bottom:30px;text-align:center}
    .options-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:20px;margin-bottom:30px}
    .option-box{padding:30px;border-radius:15px;font-size:1.2rem;font-weight:500;text-align:center;cursor:pointer;transition:all .3s;border:3px solid transparent}
    .option-a{background:#e74c3c;color:white}
    .option-b{background:#3498db;color:white}
    .option-c{background:#f39c12;color:white}
    .option-d{background:#2ecc71;color:white}
    .option-box.correct{border-color:#2ecc71;transform:scale(1.05)}
    .response-stats{margin:20px 0}
    .stat-bar{background:#f8f9fa;border-radius:10px;padding:15px;margin-bottom:10px}
    .stat-label{display:flex;justify-content:space-between;margin-bottom:8px;font-weight:500}
    .stat-progress{height:30px;background:#e5e5e5;border-radius:5px;overflow:hidden}
    .stat-fill{height:100%;background:linear-gradient(90deg,#667eea,#764ba2);transition:width .5s}
    .leaderboard{background:#f8f9fa;border-radius:15px;padding:25px;margin:30px 0}
    .leaderboard-title{font-size:1.5rem;font-weight:600;margin-bottom:20px;text-align:center}
    .podium{display:grid;grid-template-columns:repeat(3,1fr);gap:15px}
    .podium-item{text-align:center;padding:20px;background:white;border-radius:10px}
    .podium-rank{font-size:2rem;font-weight:700;margin-bottom:10px}
    .rank-1{color:#f39c12}
    .rank-2{color:#95a5a6}
    .rank-3{color:#cd7f32}
    .podium-name{font-weight:600;margin-bottom:5px}
    .podium-score{color:#667eea;font-weight:600}
    .results-screen{display:none}
    .final-title{font-size:2.5rem;font-weight:700;text-align:center;margin-bottom:40px;color:#0d0d0d}
    .btn-close{background:#e74c3c;color:white;margin-top:30px}
    .btn-close:hover{background:#c0392b}
    .empty-participants{text-align:center;color:#999;padding:20px}
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <!-- WAITING -->
      <div id="waiting-screen" class="waiting-screen">
        <h1 class="quiz-title" id="quiz-title">Chargement...</h1>
        <div class="code-display">
          <div class="code-label">Code de la session</div>
          <div class="code-value" id="session-code">------</div>
        </div>
        <div id="qrcode"></div>
        <p class="join-url">Les participants peuvent rejoindre sur : <br><strong id="join-url"></strong></p>
        <div class="participants-list">
          <div class="participants-title">Participants connect√©s (<span id="participant-count">0</span>)</div>
          <div id="participants-container">
            <div class="empty-participants">En attente des participants...</div>
          </div>
        </div>
        <button class="btn btn-primary" id="start-btn" disabled>D√©marrer le quiz</button>
      </div>

      <!-- QUESTION SCREEN -->
      <div id="question-screen" class="question-screen">
        <div class="question-header">
          <div class="question-number">Question <span id="current-question">1</span>/<span id="total-questions">10</span></div>
          <div class="timer" id="timer">30</div>
        </div>

        <div class="question-text" id="question-text"></div>
        <div class="options-grid" id="options-grid"></div>
        <div class="response-stats" id="response-stats" style="display:none;"></div>

        <div class="leaderboard" id="leaderboard" style="display:none;">
          <div class="leaderboard-title">üèÜ Top 3</div>
          <div class="podium" id="podium"></div>
        </div>

        <button class="btn btn-primary" id="next-btn" style="display:none;">Question suivante</button>
      </div>

      <!-- RESULTS -->
      <div id="results-screen" class="results-screen">
        <h1 class="final-title">üéâ Quiz termin√© !</h1>
        <div class="leaderboard">
          <div class="leaderboard-title">Classement final</div>
          <div id="final-leaderboard"></div>
        </div>
        <button class="btn btn-close" id="close-btn">Fermer la session</button>
      </div>
    </div>
  </div>

  <script>
    const SUPABASE_URL = "https://ckfdysasgawyixbxjyfz.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNrZmR5c2FzZ2F3eWl4YnhqeWZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE5ODg1NjcsImV4cCI6MjA3NzU2NDU2N30.t0ubaRk5sz7kewyEsOg4CpFvj47S9U1J1SP_3DQBmE8";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    let sessionId = null;
    let quizData = null;
    let currentQuestionIndex = 0;
    let timerInterval = null;
    let participants = [];

    // --- INIT ---
    async function init() {
      const params = new URLSearchParams(window.location.search);
      sessionId = params.get('session');
      if (!sessionId) {
        alert('Session invalide');
        window.location.href = 'dashboard.html';
        return;
      }
      await loadSession();
      subscribeToParticipants();
      subscribeToAnswers(); // keep for analytics but scoring happens on host
    }

    // Load session + quiz
    async function loadSession() {
      try {
        const { data: session, error: sessionError } = await supabase
          .from('live_sessions')
          .select('*, quizzes(*)')
          .eq('id', sessionId)
          .single();

        if (sessionError) throw sessionError;

        const quiz = session.quizzes;
        quizData = {
          ...quiz,
          questions: typeof quiz.questions === 'string' ? JSON.parse(quiz.questions) : quiz.questions
        };

        document.getElementById('quiz-title').textContent = quizData.title || 'Quiz';
        document.getElementById('session-code').textContent = session.code;
        document.getElementById('total-questions').textContent = quizData.questions.length;

        const joinUrl = `${window.location.origin}/player.html?code=${session.code}`;
        document.getElementById('join-url').textContent = joinUrl;

        QRCode.toCanvas(document.getElementById('qrcode'), joinUrl, { width:200, margin:2 });
      } catch (err) {
        console.error('Error loading session:', err);
        alert('Erreur de chargement: ' + (err.message || err));
      }
    }

    // PARTICIPANTS
    function subscribeToParticipants() {
      supabase
        .channel('participants-'+sessionId)
        .on('postgres_changes', {
          event: '*', schema: 'public', table: 'session_participants',
          filter: `session_id=eq.${sessionId}`
        }, payload => {
          loadParticipants();
        })
        .subscribe();
      loadParticipants();
    }

    async function loadParticipants() {
      const { data, error } = await supabase
        .from('session_participants')
        .select('*')
        .eq('session_id', sessionId)
        .order('joined_at', { ascending: true });

      if (error) {
        console.error('Error loading participants:', error);
        return;
      }
      participants = data || [];
      document.getElementById('participant-count').textContent = participants.length;

      const container = document.getElementById('participants-container');
      if (!participants.length) {
        container.innerHTML = '<div class="empty-participants">En attente des participants...</div>';
      } else {
        container.innerHTML = participants.map(p => `
          <div class="participant-item">
            <span class="participant-name">${escapeHtml(p.nickname)}</span>
            <span class="participant-score">${p.score || 0} pts</span>
          </div>
        `).join('');
      }
      document.getElementById('start-btn').disabled = participants.length === 0;
    }

    document.getElementById('start-btn').addEventListener('click', startQuiz);

    // START QUIZ: set status active and question index 0
    async function startQuiz() {
      await supabase
        .from('live_sessions')
        .update({ status: 'active', current_question_index: 0, question_start_time: new Date().toISOString() })
        .eq('id', sessionId);
      document.getElementById('waiting-screen').style.display = 'none';
      document.getElementById('question-screen').style.display = 'block';
      showQuestion(0);
    }

    // SHOW QUESTION: set question_start_time in DB (authoritative)
    async function showQuestion(index) {
      currentQuestionIndex = index;
      const question = quizData.questions[index];

      document.getElementById('current-question').textContent = index + 1;
      document.getElementById('question-text').textContent = question.question;
      document.getElementById('response-stats').style.display = 'none';
      document.getElementById('leaderboard').style.display = 'none';
      document.getElementById('next-btn').style.display = 'none';

      const optionsGrid = document.getElementById('options-grid');
      optionsGrid.innerHTML = '';
      const colors = ['option-a','option-b','option-c','option-d'];
      question.options.forEach((opt,i) => {
        const div = document.createElement('div');
        div.className = `option-box ${colors[i]}`;
        div.textContent = opt;
        optionsGrid.appendChild(div);
      });

      // IMPORTANT: write the authoritative question_start_time to DB (server time) so players compute remaining from it
      const startTimeISO = new Date().toISOString();
      await supabase
        .from('live_sessions')
        .update({ current_question_index: index, question_start_time: startTimeISO })
        .eq('id', sessionId);

      // start local timer for host view
      startTimer(question.timeLimit || 30);
    }

    function startTimer(seconds) {
      let timeLeft = seconds;
      const timerEl = document.getElementById('timer');
      timerEl.textContent = timeLeft;
      timerEl.classList.remove('warning');
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        timerEl.textContent = timeLeft;
        if (timeLeft <= 5) timerEl.classList.add('warning');
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          // end question and compute results
          showResults();
        }
      }, 1000);
    }

    // SUBSCRIBE TO ANSWERS (we use this for realtime stats display, but scoring is computed once when host calls showResults)
    function subscribeToAnswers() {
      supabase
        .channel('answers-'+sessionId)
        .on('postgres_changes', {
          event: 'INSERT', schema: 'public', table: 'participant_answers',
          filter: `session_id=eq.${sessionId}`
        }, payload => {
          // could update live counts if desired
        })
        .subscribe();
    }

    // SHOW RESULTS: dedupe answers, compute stats, compute points and update participants centrally
    async function showResults() {
      clearInterval(timerInterval);
      const question = quizData.questions[currentQuestionIndex];

      // fetch all answers for this question
      const { data: answersRaw, error: ansErr } = await supabase
        .from('participant_answers')
        .select('*')
        .eq('session_id', sessionId)
        .eq('question_index', currentQuestionIndex);

      if (ansErr) {
        console.error('Error fetching answers', ansErr);
      }

      const answers = answersRaw || [];

      // Deduplicate answers by participant_id: keep the earliest (smallest response_time)
      const dedup = {};
      for (const a of answers) {
        if (!a.participant_id) continue;
        if (!dedup[a.participant_id] || a.response_time < dedup[a.participant_id].response_time) {
          dedup[a.participant_id] = a;
        }
      }
      const uniqueAnswers = Object.values(dedup);

      // Calculate stats for display (percentages)
      const stats = question.options.map((_, i) => {
        const count = uniqueAnswers.filter(a => a.answer_index === i).length;
        const percentage = uniqueAnswers.length ? Math.round((count / uniqueAnswers.length) * 100) : 0;
        return { count, percentage };
      });

      // Show stats UI
      const statsContainer = document.getElementById('response-stats');
      statsContainer.style.display = 'block';
      statsContainer.innerHTML = question.options.map((opt,i) => `
        <div class="stat-bar">
          <div class="stat-label">
            <span>${escapeHtml(opt)}</span>
            <span>${stats[i].percentage}% (${stats[i].count})</span>
          </div>
          <div class="stat-progress">
            <div class="stat-fill" style="width: ${stats[i].percentage}%"></div>
          </div>
        </div>
      `).join('');

      // Highlight correct answer on host only
      const optionsBoxes = document.querySelectorAll('.option-box');
      optionsBoxes.forEach((el, idx) => el.classList.remove('correct'));
      if (optionsBoxes[question.correctIndex]) {
        optionsBoxes[question.correctIndex].classList.add('correct');
      }

      // Compute scoring per participant (aggregate then update DB once per participant)
      await computeAndApplyScores(uniqueAnswers, question);

      // update participant list display (scores updated)
      await loadParticipants();
      await showLeaderboard();

      // show next button
      document.getElementById('next-btn').style.display = 'block';
    }

    // Compute points and update participants in bulk
    async function computeAndApplyScores(answers, question) {
      if (!answers || answers.length === 0) return;
      const maxTime = (question.timeLimit || 30) * 1000;

      // accumulate points per participant
      const pointsByParticipant = {}; // participant_id -> points
      const updatesToAnswers = []; // {id, is_correct, points_earned}

      for (const ans of answers) {
        if (ans.answer_index === question.correctIndex) {
          const timeBonus = Math.max(0, Math.round((1 - (ans.response_time / maxTime)) * 500));
          const points = 1000 + timeBonus;
          pointsByParticipant[ans.participant_id] = (pointsByParticipant[ans.participant_id] || 0) + points;
          updatesToAnswers.push({ id: ans.id, is_correct: true, points_earned: points });
        } else {
          updatesToAnswers.push({ id: ans.id, is_correct: false, points_earned: 0 });
        }
      }

      // Update participant scores (one DB operation per participant)
      for (const [participantId, points] of Object.entries(pointsByParticipant)) {
        // read current score once
        const { data: pData } = await supabase
          .from('session_participants')
          .select('score')
          .eq('id', participantId)
          .single();

        const currentScore = (pData && pData.score) ? pData.score : 0;
        await supabase
          .from('session_participants')
          .update({ score: currentScore + points })
          .eq('id', participantId);
      }

      // Update participant_answers rows with is_correct & points_earned (batch updates)
      for (const u of updatesToAnswers) {
        await supabase
          .from('participant_answers')
          .update({ is_correct: u.is_correct, points_earned: u.points_earned })
          .eq('id', u.id);
      }
    }

    // Show top 3 leaderboard
    async function showLeaderboard() {
      const { data: topParticipants } = await supabase
        .from('session_participants')
        .select('*')
        .eq('session_id', sessionId)
        .order('score', { ascending: false })
        .limit(3);

      if (!topParticipants || topParticipants.length === 0) {
        document.getElementById('leaderboard').style.display = 'none';
        return;
      }

      const podium = document.getElementById('podium');
      const medals = ['ü•á','ü•à','ü•â'];
      podium.innerHTML = topParticipants.map((p,i) => `
        <div class="podium-item">
          <div class="podium-rank">${medals[i]}</div>
          <div class="podium-name">${escapeHtml(p.nickname)}</div>
          <div class="podium-score">${p.score || 0} pts</div>
        </div>
      `).join('');

      document.getElementById('leaderboard').style.display = 'block';
    }

    document.getElementById('next-btn').addEventListener('click', () => {
      if (currentQuestionIndex < quizData.questions.length - 1) {
        showQuestion(currentQuestionIndex + 1);
      } else {
        showFinalResults();
      }
    });

    async function showFinalResults() {
      await supabase
        .from('live_sessions')
        .update({ status: 'finished' })
        .eq('id', sessionId);

      document.getElementById('question-screen').style.display = 'none';
      document.getElementById('results-screen').style.display = 'block';

      const { data: finalParticipants } = await supabase
        .from('session_participants')
        .select('*')
        .eq('session_id', sessionId)
        .order('score', { ascending: false });

      const finalLeaderboard = document.getElementById('final-leaderboard');
      finalLeaderboard.innerHTML = finalParticipants?.map((p,i) => `
        <div class="participant-item" style="font-size:1.1rem;">
          <span style="font-weight:700;">#${i+1}</span>
          <span class="participant-name">${escapeHtml(p.nickname)}</span>
          <span class="participant-score">${p.score || 0} pts</span>
        </div>
      `).join('') || '';
    }

    document.getElementById('close-btn').addEventListener('click', async () => {
      await supabase.from('live_sessions').delete().eq('id', sessionId);
      window.location.href = 'dashboard.html';
    });

    function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return String(unsafe).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
    }

    // minimal subscription for participant_answers (optional)
    function subscribeToAnswers() {
      // already set above ‚Äî placeholder to avoid double-definition
    }

    init();
  </script>
</body>
</html>
